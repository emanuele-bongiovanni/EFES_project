Abstract:

The goal of the project was to put into practice all of the aspects that we analyzed during the course.
I decided to realize a Rover, a simple robot capable of autonomous movement; since i had to integrate all of the topics covered during the lesson, the rover was designed in a way to develop each of those aspects. Now i will give a brief, general description of the design of the rover, then i will show how each of the required topic was covered and finally i will examine in detail all of the parts that compose the robot.


General description:

The rover is an autonomous driving machine; it utilize an ultrasound sensor placed on the front to explore the space; while the rover is running, the distance sensor detects the distance between the rover and any obstacle in front of it. When this distance reaches a minimum, 20 cm (DA VERIFICARE), the rover stops, goes back a bit, turns randomly left or right by (INSERIRE ANGOLO DI MANOVRA) degree, and then keeps going straight again. The speed of the robot is regulated in 2 ways: when the detected distance is lower than 50 cm, the speed is fixed to (INSERIRE VELOCITÃ€). Otherwise, the speed value is proportional to the amount of light that there is above the rover; there are 4 possible speed values (VERIFICARE), the fastest when intense brightness is detected, the slowest in case of low light. In order to detect the value of brightness around the rover, a simple photo-resistor was used, hits varying voltage value measured using an Analog-to-Digital converter (that was implemented on board). To effectively vary the speed of the tracks, a PWM signal is generated and fed into the enable pins of the H-Bridge circuit that pilots the motors. All of this is implemented inside the FPGA of the provided DE1 board. The data of distance and brightness are collected and stored inside an external EEPROM memory. This is done by interfacing both the memory and the FPGA with a Nucleo Board; the Nucleo is programmed to cyclically ask the FPGA for the last distance or brightness measure, which the DE1 provides; then the Nucleo interfaces with the memory and store the obtained value. When an User presses the blue button on the DE1 is pressed, the Nucleo cycle throught the memory to extract all the stored data and prints them on a connected terminal (that needs to be opened on a connected computer).
The comunication between Nucleo-DE1 and Nucleo-EEPROM is done using the SPI protocol.


Covered Topics:

-Programmable Logic Devices:
Everithing related to the control and management of the motion of the robot and the data collection has been implemented in VHDL on the FPGA of the DE1; the principal realized unit are: SAR ADC Converter, PWM signal generator, Ultrasound sensor interface, SPI interface, Rover controller.

-AD conversion:
A SAR ADC converter has been implemented, using the DAC unit of the VGA port of the DE1, the comparator chip (INSERIRE CODICE) and a VHDL module implementing the SAR unit.

-Power Management:
The (INSERIRE NOME CHIP) H-Bridge receives 12 V inputs and uses them to run the 2 motor (effectively 10V circa exits the bridge); a PWM signal is generated by a module inside the DE1 and used to control the 2 enable signals of the H-Bridge, to tune the speed of the motors.

-Memories:
An external EEPROM, model (INSERIRE NOME CHIP), is used to store brightness and distance data coming from the DE1.

-Interconnections:
SPI has been used to allow communication from the Nucleo board with both the Memory and the DE1; the memory had an integrated SPI interface while for the DE1 one has been developed.

-Processor peripheral:
From the point of view of the Nucleo board, both the DE1 and the memory are external peripheral; to interact with them Status, Control and Data register where used (for the DE1 no status register was actually implemented because the system was quite simple itself).


List of component used:


INSERIRE ELENCO COMPONENTI


Ultrasound sensor and distance module:

The sensor has an input signal, TRIGGER, and an output signal, ECHO; when the trigger signal is kept at '1' for at least 10 us, the module starts a new measure: it sends a series of ultrasound pulses while raising the echo signal at 1; when the module detects the ultrasounds coming back, it lowers the echo signal, and the system is ready to start again.

In order to correctly interface with the module, a Finite State Machine was created: when a new measure is required, the system goes into START state (VERIFICARE I NOMI), where the signal connected to trigger is kept high, and a first counter (used as a timer) is started, to wait for the 10 us; after that, the machine goes into a wait state, because the echo signal is not rised immediatly (VERIFICARE QUESTA COSA); when echo is raised, the machine goes into MEASURING state, where a second timer starts; when echo is lowered, the timer stops and the total number of count is elaborated and sent to a register, to be available for reading.

The elaboration is needed because the time measured is the interval between when the sound is sent and when is received; basically it needs to be divided by 2 (because it's a round trip), multiplied by the speed of sound, to get the distance. At the end, it was matter of multiply and divide for some number.
Here a problem arose since inside the FPGA division is not supported; so starting from the 2 values from multiplication and division, i searched for another couple of values, where the ratio was the same (or at least very similar), but the denominator (the division amount) was a power of 2; once i found them, i could implement the division by means of shifting.

During tests the result required some tuning of the constants, but after that, the measuring was quite precise, with error in the range of 1-5 cm, for measures below the meter.
Strangely, while measuring distances bigger the the meter, the sensor becomes quite unreliable, but a look at the waveform, using the oscilloscope, showed that was probably some inner problem of the sensor. Still, since for this project it's used for short range measure, and in that range it was quite precise, i was satisfied with the result.


Analog to digital converter and brightness measurement

The development of this particular module was quite challenging; at least 3 different attempt at writing the components where made, 2 first 2 using a behavioural approach, the third, and last, with a structural one. The first 2 attempt were giving a series of problem, the first being a high instability of the signals, that, when measured, were very noisy and difficult to comprehend. The structural approach provided an adequate level of stability, that also helped with the "debugging" of the signals, using the oscilloscope.

The developed unit is a Successive Approximation Register ADC; for the structural implementation, few components have been designed:

INSERIRE ELENCO COMPONENTI SAR

A Finite state machine controls the behaviour of the components;

INSERIRE STADI FSM E RELATIVA SPIEGAZIONE

The ADC is used to measure the voltage value at the terminals of a photo-resistor; 
An adequate conditioning circuit (basically some voltage divider) was needed in order to have a voltage in the range of the DAC (maximum voltage: 1.35V): starting from a 5V supply, a voltage division (using available resistor) to obtain something around 1.35 volt was created; then the photo-resistor was put in series with a (INSERIRE VALORE) resistor, and the input for the DAC was taken from the terminals of the photo-resistor; during test phases, data was gathered to chracterize the circuit, and understand which value of reading were related to the level of brightness above the rover; this was needed in order to decide the value of the thresholds to use inside the controller for the speed settings.
Below is a table with the data aquired during measuring phase.

INSERIRE TABELLA

